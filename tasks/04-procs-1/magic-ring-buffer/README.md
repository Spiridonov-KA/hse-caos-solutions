# Magic ring buffer

Вы наверняка писали [циклический буфер](https://en.wikipedia.org/wiki/Circular_buffer) –
структуру поверх массива с двумя указателями – началом и концом, с помощью
которой можно реализовать интерфейс, очень похожий на
[`std::deque`](https://en.cppreference.com/w/cpp/container/deque.html).

Также вы скорее всего заметили, что для многих интерфейсов операционной системы
требуется, чтобы данные лежали подряд в памяти, что в случае обычного циклического
буфера невозможно обеспечить без дополнительных накладных расходов.
В этой задаче вам предстоит реализовать циклический буфер, данные которого
всегда лежат подряд в памяти.

Реализуйте методы:

- `std::variant<RingBuffer, int> Create(size_t capacity)` – создает циклический буфер на не менее, чем `capacity` элементов. В случае возникновения ошибки верните ее код
- `size_t Capacity()` – возвращает фактическую вместимость буфера
- `void (Push/Pop)(Back/Front)` – добавляет/удаляет элемент в начало/конец буфера
- `std::span<ElementType> Data()` – возвращает непрерывный участок памяти, в котором находится содержимое буфера

Все методы кроме `Create` должны работать за $O(1)$ гарантированно.

Гарантируется, что методы `Push*` не будут вызываться на полном буфере, а методы `Pop*` не
будут вызываться на пустом.

<details>
<summary>Идея реализации</summary>

С помощью [`mremap`](https://www.man7.org/linux/man-pages/man2/mremap.2.html)
создайте копию отображения содержимого буфера и расположите ее сразу
после содержимого буфера. Таким образом, благодаря тому, что копия
будет ссылаться на те же физические страницы в ней будут находиться те же данные,
что и в основной части.

Теперь, если данные в циклическом буфере лежат не последовательно, возьмите
префикс данных из основной части (суффикс основной части буффера) и суффикс данных
из копии (префикс копии).

</details>
