# Allocator

## Пререквизиты

- [`simple-allocator`](../../03-mmap/simple-allocator)

---

Вы уже написали первый аллокатор блоков фиксированной длины, в данной задаче мы разовьем
эту идею до первого аллокатора общего назначения, который позволяет выделять блоки
памяти произвольного размера. Реализуйте два метода:

- `void* Allocate(size_t size)` – выделяет блок памяти размера хотя бы `size`, возвращает `nullptr`, если память выделить не получилось
- `void Deallocate(void* ptr)` – освобождает блок памяти, который ранее был выделен с помощью `Allocate`

## Идея и требования к реализации

Для аллокаций блоков памяти произвольного размера можно скомбинировать несколько аллокаторов
блоков фиксированного размера и маршрутизировать запросы на аллокацию между ними. Предлагается
создать аллокаторы для блоков размера `32` байта, `64` байта, ..., `2048` байт, и, при запросе
на аллокацию, округлять ее размер до первого блока фиксированного размера, который могут выделить
аллокаторы фиксированного размера. Если запрашиваемый блок больше самого большого блока, который
могут выделять аллокаторы фиксированного размера, выделяйте его с помощью `mmap`. При освобождении
таких блоков освобождайте память с помощью `munmap`.

### Nostd

Как и в `simple-allocator`, в этой задаче ваше решение будет собираться [без стандартной библиотеки](../../../docs/nostd.md).

### Метаинформация

Так как при освобождении блока памяти аллокатору не сообщается его размер, его нужно сохранить
отдельно. Предлагается для каждого запроса памяти выделять `size + 8` байт памяти и сохранять
в первых 8 байтах размер выделенного блока. Таким образом, по указателю на начало блока
всегда можно выяснить его настоящий размер.

### Выравнивание

Все выделяемые блоки должны быть выравнены по 16 байтам. Это означает, что численное значение
адреса начала каждого из блоков должно быть кратно 16. Для удовлетворения этого требования вам
может потребоваться увеличить размер заголовка с метаданными до 16 байт. Такому же требованию
удовлетворяют стандартные аллокаторы `malloc` и `operator new`.
(Технически `operator new` выдает блоки, выровненные по `alignof(std::max_align_t)` байтам,
на типичных `x86_64` это значение равно 16 байтам)

## Критика дизайна

Во многих аспектах данный дизайн аллокатора плох. В частности, он:

- Увеличивает расход памяти в среднем в 1.5 раза и в худшем – в 2 раза для маленьких аллокаций
- Не умеет отпускать неиспользуемые страницы, выделенные под блоки маленьких размеров
- Не умеет переиспользовать страницы, выделяемые для блоков больших размеров
- Хранит метаданные рядом с выделенными блоками, что, в случае выходов за границы выделенного блока с большой вероятностью приведет к некорректной работе аллокатора

## Полезные ссылки

О том, как делаются хорошие аллокаторы, вы можете узнать тут:

- [Andrei Alexandrescu "std::allocator Is to Allocation what std::vector Is to Vexation"](https://www.youtube.com/watch?v=LIb3L4vKZ7U)
- [Tick Tock, malloc Needs a Clock](https://www.youtube.com/watch?v=RcWp5vwGlYU&list=PLn0nrSd4xjjZoaFwsTnmS1UFj3ob7gf7s)
- [Mimalloc: Free List Sharding in Action](https://www.microsoft.com/en-us/research/wp-content/uploads/2019/06/mimalloc-tr-v1.pdf) – описание устройства и замеры производительности аллокатора mimalloc
- [TCMalloc: Thread-Caching Malloc](https://google.github.io/tcmalloc/design.html) – краткое описание дизайна TCMalloc
