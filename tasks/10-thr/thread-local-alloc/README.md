# Thread-local alloc

В этой задачке вы напишете thread-aware аллокатор. Как вы уже могли заметить,
синхронизация потоков несет в себе дополнительные накладные расходы, поэтому в аллокаторах,
чтобы избежать синхронизации, часто используют thread-local арены. В случае, если
в такой арене возможно выделить необходимый кусок памяти, потоку не нужно обращаться в
общую арену, синхронизируясь с другими потоками. Например, в
[реализации](https://elixir.bootlin.com/glibc/glibc-2.41.9000/source/malloc/malloc.c#L3127)
`malloc` в `glibc` используется
[tcache](https://sourceware.org/glibc/wiki/MallocInternals#Thread_Local_Cache_.28tcache.29)
-- отдельная арена для этих целей.

В этой задаче вы реализуете похожий механизм. В файле [storage.hpp](./storage.hpp) вы можете
найти функции, которые вам надо реализовать. `Alloc` должен уметь аллоцировать память без
синхронизации с другими потоками, а также записывать статистику о своем использовании.

`OnThreadStart`/`OnThreadStop` вызываются в начале/конце работы треда. В `OnThreadStart`
передается указатель на структуру `Stat`, в которую вам нужно записывать статистику
аллокаций.

Для простоты реализации, деаллоцировать возможно только всю аллоцированную потоком память
с помощью метода `Dealloc`. Этот же метод должен сбрасывать всю статистику аллокаций.

Гарантируется, что суммарный размер всех аллокаций в одном потоке между соседними вызовами
`Dealloc` не превосходит 1MB. Так же гарантируется, что `alignment` – степень двойки.

Не допускайте лишней коммуникации между потоками (в том числе неявной). Возможно, для
прохождения тестов вам понадобится прочитать их код ;)

Обратите внимание на то, что вы [можете](./testing.yaml#L13) менять в том числе заголовочный
файл.

## Локализация проблем с производительностью

Часто для локализации проблем с производительностью используется утилита [`perf`](https://www.man7.org/linux/man-pages/man1/perf.1.html).

У нее довольно обширный функционал, одна из ее возможностей – получение статистик об
исполнении программы от процессора. Для получения этих статистик используется
[`perf stat`](https://www.man7.org/linux/man-pages/man1/perf-stat.1.html):

```bash
sudo perf stat -ddd -- ../../../build_release/test_thread_local_alloc CheckContention
```

Часть проблем удается локализовать путем анализа статистик (например, если счетчик `branch-misses`
имеет такой же порядок значeний, как и `branches` – скорее всего, в коде проблема с branch
misprediction).

Далее можно выполнить _сэмплирование_ приложения – время от времени собирать сэмпл в виде стектрейса
и по нему понимать, в каких местах приложение проводит много времени.

```bash
sudo perf record -F 1000 -g -- ../../../build_release/test_thread_local_alloc CheckContention
```

Эта команда соберет сэмплы приложения в файл `perf.data`. Просмотреть его можно с помощью, например
[`perf report`](https://www.man7.org/linux/man-pages/man1/perf-report.1.html):

```bash
sudo perf report
```

Она откроет TUI с самыми "горячими" функциями, далее можно выбрать какую-нибудь
из них, выбрать "Annotate \<function\>" и посмотреть на инструкции, которые
выполняются дольше всего.

Альтернативный способ просмотра сэмплов – [flamegraph](https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html).

## Полезные ссылки

- [perf examples](https://www.brendangregg.com/perf.html)
- [A Top-Down Method for Performance Analysis and Counters Architecture](https://rcs.uwaterloo.ca/~ali/cs854-f23/papers/topdown.pdf)
