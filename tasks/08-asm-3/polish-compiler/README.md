# Polish compiler

Рассмотрим выражения, записанные в
[обратной польской записи](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C).
Данная запись представляет арифметические выражения в удобном для вычисления формате. А именно,
вычислять подобные выражения можно, обрабатывая выражение слева-направо и поддерживая стек чисел. Если
очередной элемент выражения – число или переменная, значение кладется на стек. Если элемент
выражения – бинарная арифметическая операция, два верхних элемента стека достаются и используются,
как аргументы бинарной операции, после чего результат операции кладется на стек. Если выражение
корректно, после этих операций в стеке останется единственное число – значение выражения.

Ваша задача – написать "компилятор" для подобных выражений, генерирующий последовательность
машинных инструкций для эффективного вычисления переданного выражения.

Например, для выражения `x y z + *` ваш компилятор может сгенерировать следующую последовательность
инструкций, вычисляющее значение данного выражения.

```plain
push rdi
push rsi
push rdx

pop rax
add [rsp], rax

pop rdx
pop rax
mul rdx
push rax

pop rax
ret
```

Эта последовательность инструкций может быть использована как функция трех аргументов, вычисляющая
данное выражение. В качестве стека, хранящего промежуточные результаты вычисления выражения,
используется основной стек.

Ваш компилятор должен поддерживать следующие "инструкции":

- `BinaryOp` – с вершины стека достаются два числа, с ними производится указанная в `kind` операция и результат
    вычисления кладется на вершину стека.
- `Duplicate` – на вершину стека кладется значение, находящееся на расстоянии `from` от текущей вершины стека
- `Push` – добавляет на вершину стека значение `value`
- `Pop` – удаляет с вершины стека одно значение
- `Swap` – меняет местами два верхних элемента стека
- `TraceElement` – вызывает `trace_fn` на аргументе `data` и значении, находящемся на расстоянии `index` от текущей вершины стека

Функция `PolishCompiler::Compile` принимает выражение в обратной польской записи и количество
"аргументов" выражения. Перед началом вычисления выражения все аргументы кладутся на стек
в порядке слева-направо (последний аргумент находится на вершине стека). `Compile` должен вернуть
указатель на начало скомпилированного в машинный код выражения, который можно использовать как
функцию соответствующего количества аргументов. Например

```cpp
auto raw = = compiler.Compile({{
    Push{3},
    add,
    mult,
}}, 2);
auto fn = reinterpret_cast<uint64_t(*)(uint64_t, uint64_t)>(raw);

// fn(a, b) == a * (b + 3)
```

Все вычисления производятся в арифметике по модулю $2^{64}$.

В случае, если переданное выражение некорректно (содержит обращение к несуществующему элементу стека,
в конце вычислений в стеке находится не один элемент), `Compile` должен вернуть `nullptr`.
Ввиду простоты рассматриваемого "языка", все подобные условия можно проверять статически.

В файле [`./tests/common.hpp`](./tests/common.hpp) вы можете найти реализацию интерпретатора
выражений, в случае неоднозначностей следует обращаться к нему.

Вы можете создавать новые файлы в папке `src/`, и структурировать свое решение по своему усмотрению.

## Тестирование

Данная задача разбита на две части – базовую и бонусную. В базовой версии от вас не требуется
реализовывать `TraceElement`, а также вам гарантируется, что значения `value` во всех
операциях `Push` не превосходят $2^{31} - 1$.

При запуске `cargo xtask test` будут запускаться тесты обеих частей, если у вас реализована только
первая часть, запуск тестов второй части будет проваливаться, но баллы в систему за первую часть
будут выставляться.

## Полезные советы

### Кодировка инструкций

Для получения кодировки нужных инструкций, вы можете скомпилировать мини-программу
и посмотреть на ее содержимое с помощью objdump:

```plain
$ cat test.S
.intel_syntax noprefix
.text
.global f
f:
    pop rax
    add [rsp], rax
    ret

$ g++ test.S -o test.o -c && objdump -d -j .text -Mintel test.o

test.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <f>:
   0:   58                      pop    rax
   1:   48 01 04 24             add    QWORD PTR [rsp],rax
   5:   c3                      ret
```

Иногда `llvm-objdump` дает результаты лучше, чем `objdump`.

Сравните ваши находки о кодировании x86 инструкций с их
[online reference](https://www.felixcloutier.com/x86/).

### Работа с `std::variant`

Для работы с `std::variant` вы можете использовать `std::visit` вместе с `Overload`:

```cpp
#include <overload.hpp>

struct A { /* ... */ };
struct B { /* ... */ };
struct C { /* ... */ };

std::variant<A, B, C> value = /* ... */;
std::visit(
    Overload{
        [](const A& value) {
            // Handle case A
        },
        [](const B& value) {
            // Handle case B
        },
        [](const C& value) {
            // Handle case C
        },
    },
    value
);
```

## Качество сгенерированных инструкций

Если вы посмотрите на сгенерированные машинные инструкции, вы скорее всего увидите
много неэффективностей, например, последовательности вида

```asm
push rax
pop rax
```

От них можно попытаться избавиться более сложным алгоритмом генерации инструкций. В данной задаче
достаточно генерировать инструкции независимо для каждой операции в выражении.
