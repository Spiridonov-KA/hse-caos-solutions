# Философы

За круглым столом сидят $n$ философов, между каждой парой соседей лежит вилка. Каждый
философ либо ест, либо размышляет. Перед тем, как начать есть, философ должен взять в руки
левую и правую вилку, из этого следует, что никакие два соседних философа не могут есть
одновременно.

Реализуйте методы для структуры [`Table`](./table.cpp) в файле [`table.cpp`](./table.cpp),
для координации трапезы философов. Реализуйте два метода:

- `StartEating` – философ с номером `i` вызывает `StartEating(i)` когда желает
    начать трапезу. Метод должен заблокировать текущий поток до тех пор,
    пока философ не возьмет в руки обе вилки.
- `StopEating` – философ с номером `i` вызывает `StopEating(i)`, когда
    заканчивает трапезу. Гарантируется, что каждому вызову `StopEating(i)`
    соответствует предшедствующий вызов `StartEating(i)`, совершенный
    тем же потоком.

Не используйте активное ожидание и циклы, не используйте `try_lock`.

## Граф ожидания

Рассмотрим ориентированный двудольный граф, в котором вершинами левой доли являются
потоки, а вершинами правой доли – блокировки. Проведем ребро из потока в блокировку,
если блокировка захвачена потоком. Проведем ребро из блокировки в поток, если поток
ожидает захвата блокировки. Как в терминах этого графа определяется deadlock? Как
избежать подобную ситуацию?

## Полезные ссылки

- [Deadlock empire](https://deadlockempire.github.io/)
