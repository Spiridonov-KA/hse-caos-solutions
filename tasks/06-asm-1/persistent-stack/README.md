# Persistent stack

Реализуйте [персистентный стек](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%B5%D1%80%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B9_%D1%81%D1%82%D0%B5%D0%BA)
с автоматическим управлением памятью. Узлом стека будет служить структура `Node` следующего вида:

```cpp
struct Node {
    Node* next;
    uint64_t reference_count;
    uint64_t value;
};
```

В поле `reference_count` хранится количество ссылок на данный узел персистентного стека. Когда
`reference_count` достигает значения 0, узел удаляется, а `reference_count` узла
`next` уменьшается на 1, если он существует.

В файле [`stack.S`](./stack.S) реализуйте 3 функции:

- `void IncRef(Node* node)` – увеличивает счетчик ссылок узла на 1.
- `void DecRef(Node* node)` – уменьшает счетчик ссылок узла на 1, выполняя каскадное удаление узлов.
- `Node* Push(Node* head, uint64_t value)` – добавляет в персистентный стек с головой `head` новый узел со значением `value`, возвращает голову новой версии стека. У нового узла стека счетчик ссылок должен быть равен 1. У `head`, если он не `nullptr`, счетчик ссылок должен увеличиться на 1.

Гарантируется, что в `IncRef` и `DecRef` передаются только указатели, полученные от вызова функции `Push`.

Узлы персистентного стека следует аллоцировать на куче, например, с использованием `malloc` и `free`.
Перед их использованием нужно выровнять стек по 16 байтам согласно calling conventions. Согласно
тем же calling conventions на момент вызова ваших функций стек так же был выроновнен по 16 байтам.
Для `malloc` и `free` достаточно сделать `call malloc`/`call free`.

Также не забывайте, что вызываемые функции могут поменять значение caller-saved регистров.

Постарайтесь реализовать `DecRef` без использования рекурсии.
